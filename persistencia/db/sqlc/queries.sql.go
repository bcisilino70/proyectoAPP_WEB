// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"time"
)

const createCliente = `-- name: CreateCliente :one
INSERT INTO CLIENTE (nombre,apellido,usuario,pass,email)
VALUES ($1,$2,$3,$4,$5)
RETURNING id,nombre,apellido,usuario,pass,email
`

type CreateClienteParams struct {
	Nombre   string `json:"nombre"`
	Apellido string `json:"apellido"`
	Usuario  string `json:"usuario"`
	Pass     string `json:"pass"`
	Email    string `json:"email"`
}

func (q *Queries) CreateCliente(ctx context.Context, arg CreateClienteParams) (Cliente, error) {
	row := q.db.QueryRowContext(ctx, createCliente,
		arg.Nombre,
		arg.Apellido,
		arg.Usuario,
		arg.Pass,
		arg.Email,
	)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.Nombre,
		&i.Apellido,
		&i.Usuario,
		&i.Pass,
		&i.Email,
	)
	return i, err
}

const createResena = `-- name: CreateResena :one
INSERT INTO RESENA (titulo,descripcion,nota,cliente_id)
VALUES ($1,$2,$3,$4)
RETURNING id,titulo,descripcion,nota,fecha,cliente_id
`

type CreateResenaParams struct {
	Titulo      string `json:"titulo"`
	Descripcion string `json:"descripcion"`
	Nota        int32  `json:"nota"`
	ClienteID   int32  `json:"cliente_id"`
}

// Pensar como se coloca el ID del cliente que hace la resena. No parece ser un problema para las queries.
func (q *Queries) CreateResena(ctx context.Context, arg CreateResenaParams) (Resena, error) {
	row := q.db.QueryRowContext(ctx, createResena,
		arg.Titulo,
		arg.Descripcion,
		arg.Nota,
		arg.ClienteID,
	)
	var i Resena
	err := row.Scan(
		&i.ID,
		&i.Titulo,
		&i.Descripcion,
		&i.Nota,
		&i.Fecha,
		&i.ClienteID,
	)
	return i, err
}

const deleteCliente = `-- name: DeleteCliente :exec
DELETE FROM CLIENTE
WHERE (id = $1)
`

// Consulta para borrar un cliente
func (q *Queries) DeleteCliente(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteCliente, id)
	return err
}

const deleteResena = `-- name: DeleteResena :exec
DELETE FROM RESENA 
WHERE (id = $1) AND (cliente_id = $2)
`

type DeleteResenaParams struct {
	ID        int32 `json:"id"`
	ClienteID int32 `json:"cliente_id"`
}

// Consulta para borrar una resena.
func (q *Queries) DeleteResena(ctx context.Context, arg DeleteResenaParams) error {
	_, err := q.db.ExecContext(ctx, deleteResena, arg.ID, arg.ClienteID)
	return err
}

const getCliente = `-- name: GetCliente :one
SELECT nombre, apellido, usuario, email
FROM CLIENTE
WHERE (id = $1)
`

type GetClienteRow struct {
	Nombre   string `json:"nombre"`
	Apellido string `json:"apellido"`
	Usuario  string `json:"usuario"`
	Email    string `json:"email"`
}

// Permite traer un cliente
func (q *Queries) GetCliente(ctx context.Context, id int32) (GetClienteRow, error) {
	row := q.db.QueryRowContext(ctx, getCliente, id)
	var i GetClienteRow
	err := row.Scan(
		&i.Nombre,
		&i.Apellido,
		&i.Usuario,
		&i.Email,
	)
	return i, err
}

const getClienteUsuarioYPass = `-- name: GetClienteUsuarioYPass :one
SELECT id, nombre, apellido, usuario, pass, email
FROM CLIENTE
WHERE usuario = $1 AND pass = $2
`

type GetClienteUsuarioYPassParams struct {
	Usuario string `json:"usuario"`
	Pass    string `json:"pass"`
}

// Permite buscar un cliente para el login
func (q *Queries) GetClienteUsuarioYPass(ctx context.Context, arg GetClienteUsuarioYPassParams) (Cliente, error) {
	row := q.db.QueryRowContext(ctx, getClienteUsuarioYPass, arg.Usuario, arg.Pass)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.Nombre,
		&i.Apellido,
		&i.Usuario,
		&i.Pass,
		&i.Email,
	)
	return i, err
}

const listCliente = `-- name: ListCliente :many
SELECT nombre, apellido, usuario, email
FROM CLIENTE
`

type ListClienteRow struct {
	Nombre   string `json:"nombre"`
	Apellido string `json:"apellido"`
	Usuario  string `json:"usuario"`
	Email    string `json:"email"`
}

// Permite mostrar todos los clientes
func (q *Queries) ListCliente(ctx context.Context) ([]ListClienteRow, error) {
	rows, err := q.db.QueryContext(ctx, listCliente)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClienteRow
	for rows.Next() {
		var i ListClienteRow
		if err := rows.Scan(
			&i.Nombre,
			&i.Apellido,
			&i.Usuario,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResena = `-- name: ListResena :one
SELECT titulo, descripcion, nota, fecha 
FROM RESENA
WHERE (cliente_id = $1) and (titulo = $2)
`

type ListResenaParams struct {
	ClienteID int32  `json:"cliente_id"`
	Titulo    string `json:"titulo"`
}

type ListResenaRow struct {
	Titulo      string    `json:"titulo"`
	Descripcion string    `json:"descripcion"`
	Nota        int32     `json:"nota"`
	Fecha       time.Time `json:"fecha"`
}

// Consulta para listar UNA resena de un cliente.
func (q *Queries) ListResena(ctx context.Context, arg ListResenaParams) (ListResenaRow, error) {
	row := q.db.QueryRowContext(ctx, listResena, arg.ClienteID, arg.Titulo)
	var i ListResenaRow
	err := row.Scan(
		&i.Titulo,
		&i.Descripcion,
		&i.Nota,
		&i.Fecha,
	)
	return i, err
}

const listResenas = `-- name: ListResenas :many
SELECT titulo, descripcion, nota, fecha 
FROM RESENA
WHERE (cliente_id = $1)
`

type ListResenasRow struct {
	Titulo      string    `json:"titulo"`
	Descripcion string    `json:"descripcion"`
	Nota        int32     `json:"nota"`
	Fecha       time.Time `json:"fecha"`
}

// Consulta para listar TODAS resenas de un cliente.
func (q *Queries) ListResenas(ctx context.Context, clienteID int32) ([]ListResenasRow, error) {
	rows, err := q.db.QueryContext(ctx, listResenas, clienteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResenasRow
	for rows.Next() {
		var i ListResenasRow
		if err := rows.Scan(
			&i.Titulo,
			&i.Descripcion,
			&i.Nota,
			&i.Fecha,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCliente = `-- name: UpdateCliente :exec
UPDATE CLIENTE
SET email = $1
WHERE (id = $2)
`

type UpdateClienteParams struct {
	Email string `json:"email"`
	ID    int32  `json:"id"`
}

// Permite al cliente cambiar el email.
func (q *Queries) UpdateCliente(ctx context.Context, arg UpdateClienteParams) error {
	_, err := q.db.ExecContext(ctx, updateCliente, arg.Email, arg.ID)
	return err
}

const updateResena = `-- name: UpdateResena :exec
UPDATE RESENA                           
SET titulo = $1, descripcion = $2, nota = $3
WHERE (id = $4) AND (cliente_id = $5)
`

type UpdateResenaParams struct {
	Titulo      string `json:"titulo"`
	Descripcion string `json:"descripcion"`
	Nota        int32  `json:"nota"`
	ID          int32  `json:"id"`
	ClienteID   int32  `json:"cliente_id"`
}

func (q *Queries) UpdateResena(ctx context.Context, arg UpdateResenaParams) error {
	_, err := q.db.ExecContext(ctx, updateResena,
		arg.Titulo,
		arg.Descripcion,
		arg.Nota,
		arg.ID,
		arg.ClienteID,
	)
	return err
}
