// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"time"
)

const createCliente = `-- name: CreateCliente :one
INSERT INTO CLIENTE (nombre,apellido,usuario,pass,email)
VALUES ($1,$2,$3,$4,$5)
RETURNING id,nombre,apellido,usuario,pass,email
`

type CreateClienteParams struct {
	Nombre   string `json:"nombre"`
	Apellido string `json:"apellido"`
	Usuario  string `json:"usuario"`
	Pass     string `json:"pass"`
	Email    string `json:"email"`
}

func (q *Queries) CreateCliente(ctx context.Context, arg CreateClienteParams) (Cliente, error) {
	row := q.db.QueryRowContext(ctx, createCliente,
		arg.Nombre,
		arg.Apellido,
		arg.Usuario,
		arg.Pass,
		arg.Email,
	)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.Nombre,
		&i.Apellido,
		&i.Usuario,
		&i.Pass,
		&i.Email,
	)
	return i, err
}

const createResena = `-- name: CreateResena :one
INSERT INTO RESENA (titulo,descripcion,nota,fecha,cliente_id)
VALUES ($1,$2,$3,$4,$5)
RETURNING id,titulo,descripcion,nota,fecha,cliente_id
`

type CreateResenaParams struct {
	Titulo      string    `json:"titulo"`
	Descripcion string    `json:"descripcion"`
	Nota        int32     `json:"nota"`
	Fecha       time.Time `json:"fecha"`
	ClienteID   int32     `json:"cliente_id"`
}

// Pensar como se coloca el ID del cliente que hace la resena. No parece ser un problema para las queries.
func (q *Queries) CreateResena(ctx context.Context, arg CreateResenaParams) (Resena, error) {
	row := q.db.QueryRowContext(ctx, createResena,
		arg.Titulo,
		arg.Descripcion,
		arg.Nota,
		arg.Fecha,
		arg.ClienteID,
	)
	var i Resena
	err := row.Scan(
		&i.ID,
		&i.Titulo,
		&i.Descripcion,
		&i.Nota,
		&i.Fecha,
		&i.ClienteID,
	)
	return i, err
}

const deleteCliente = `-- name: DeleteCliente :exec
DELETE FROM CLIENTE
WHERE (usuario = $1)
`

// Consulta para borrar un cliente
func (q *Queries) DeleteCliente(ctx context.Context, usuario string) error {
	_, err := q.db.ExecContext(ctx, deleteCliente, usuario)
	return err
}

const deleteResena = `-- name: DeleteResena :exec
DELETE FROM RESENA 
WHERE (titulo = $1)
`

// Consulta para borrar una resena.
func (q *Queries) DeleteResena(ctx context.Context, titulo string) error {
	_, err := q.db.ExecContext(ctx, deleteResena, titulo)
	return err
}

const listResena = `-- name: ListResena :one
SELECT titulo, descripcion, nota, fecha 
FROM RESENA
WHERE (cliente_id = $1) and (titulo = $2)
`

type ListResenaParams struct {
	ClienteID int32  `json:"cliente_id"`
	Titulo    string `json:"titulo"`
}

type ListResenaRow struct {
	Titulo      string    `json:"titulo"`
	Descripcion string    `json:"descripcion"`
	Nota        int32     `json:"nota"`
	Fecha       time.Time `json:"fecha"`
}

// Consulta para listar UNA resena de un cliente.
func (q *Queries) ListResena(ctx context.Context, arg ListResenaParams) (ListResenaRow, error) {
	row := q.db.QueryRowContext(ctx, listResena, arg.ClienteID, arg.Titulo)
	var i ListResenaRow
	err := row.Scan(
		&i.Titulo,
		&i.Descripcion,
		&i.Nota,
		&i.Fecha,
	)
	return i, err
}

const listResenas = `-- name: ListResenas :many

SELECT titulo, descripcion, nota, fecha 
FROM RESENA
WHERE (cliente_id = $1)
`

type ListResenasRow struct {
	Titulo      string    `json:"titulo"`
	Descripcion string    `json:"descripcion"`
	Nota        int32     `json:"nota"`
	Fecha       time.Time `json:"fecha"`
}

// El cliente puede actualizar una resena pero no sabe el id de la misma. A chequear
// Consulta para listar TODAS resenas de un cliente.
func (q *Queries) ListResenas(ctx context.Context, clienteID int32) ([]ListResenasRow, error) {
	rows, err := q.db.QueryContext(ctx, listResenas, clienteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResenasRow
	for rows.Next() {
		var i ListResenasRow
		if err := rows.Scan(
			&i.Titulo,
			&i.Descripcion,
			&i.Nota,
			&i.Fecha,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCliente = `-- name: UpdateCliente :exec
UPDATE CLIENTE
SET email = $1
WHERE (usuario = $2) AND (pass = $3)
`

type UpdateClienteParams struct {
	Email   string `json:"email"`
	Usuario string `json:"usuario"`
	Pass    string `json:"pass"`
}

// Permite al cliente cambiar el email.
func (q *Queries) UpdateCliente(ctx context.Context, arg UpdateClienteParams) error {
	_, err := q.db.ExecContext(ctx, updateCliente, arg.Email, arg.Usuario, arg.Pass)
	return err
}

const updateResena = `-- name: UpdateResena :exec
UPDATE RESENA                           
SET titulo = $1, descripcion = $2
WHERE (titulo = $3) AND (cliente_id = $4)
`

type UpdateResenaParams struct {
	Titulo      string `json:"titulo"`
	Descripcion string `json:"descripcion"`
	Titulo_2    string `json:"titulo_2"`
	ClienteID   int32  `json:"cliente_id"`
}

func (q *Queries) UpdateResena(ctx context.Context, arg UpdateResenaParams) error {
	_, err := q.db.ExecContext(ctx, updateResena,
		arg.Titulo,
		arg.Descripcion,
		arg.Titulo_2,
		arg.ClienteID,
	)
	return err
}
